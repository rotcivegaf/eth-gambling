function createP2PBet() external {

    P2PBet({
        creator: msg.sender,
        betCreator: _currency,
        payPlayer: 0,
        player: msg.sender,
        betPlayer: _model,
        payCreator: _oracle
    });

    Status status;

    bytes32 gambling;
    IBetOracle oracle;

    _createBet(gambling, oracle);



    Match storage matchAux = matches[_matchId];
    require(matchAux.timeNoMoreBets >= now, "the bets should are opened");
    require(addressToBalance[msg.sender] >= _value , "insufficient founds");

    addressToBalance[msg.sender] -= _value;

    if(matchAux.addressToTeam[msg.sender] == 0){
        matchAux.addressToTeam[msg.sender] = _winTeamId;
    } else {
        _winTeamId = matchAux.addressToTeam[msg.sender];
    }

    if(_winTeamId == matchAux.team1){
        matchAux.balance1 += _value;
    }else{
        if(_winTeamId == matchAux.team2){
            matchAux.balance2 += _value;
        }else{
            matchAux.balanceD += _value;
        }
    }

    matchAux.addressToBalance[msg.sender] += _value;
}

function chargeGambling(uint _matchId, address _owner) public {
    Match storage matchAux = matches[_matchId];
    uint winTeam = matchAux.winTeam;
    require(winTeam != 0, "team win should not be None");
    require(matchAux.addressToBalance[_owner] > 0, "the owner dont have gambling or its charged");
    require(matchAux.addressToTeam[_owner] == winTeam, "the sender dont win");

    uint userBal = matchAux.addressToBalance[_owner];
    matchAux.addressToBalance[_owner] = 0;

    if(winTeam == matchAux.team1){
        addressToBalance[_owner] += getTotalwin(userBal, matchAux.balance1, matchAux.balanceD + matchAux.balance2);
    }else{
        if(winTeam == matchAux.team2){
            addressToBalance[_owner] += getTotalwin(userBal, matchAux.balance2, matchAux.balance1 + matchAux.balanceD);
        }else{// draw
            addressToBalance[_owner] += getTotalwin(userBal, matchAux.balanceD, matchAux.balance1 + matchAux.balance2);
        }
    }
    emit ChargeGambling(_owner, _matchId);
}

function getTotalwin(uint _userBal, uint _totWinBal, uint _totLoseBal) internal pure returns(uint) {
    return ((_userBal * _totLoseBal) / _totWinBal) + _userBal;
}

contract StorageHelper is BalanceManager {
    enum Status { created, played, paid, destroyed }

    struct P2PBet {
        address creator;
        bytes32 betCreator;
        uint256 payPlayer;

        address player;
        bytes32 betPlayer;
        uint256 payCreator;

        Status status;

        bytes32 gambling;
        IBetOracle oracle;
    }

    struct MultiBet {
        mapping (address => uint256) playerToBalance;
        mapping (address => bytes32) playerToOption;

        mapping (bytes32 => uint256) optionToBalance;
        uint256 balance;

        Status status;

        bytes32 gambling;
        IBetOracle oracle;
    }

    P2PBet[]   public p2PBets;
    MultiBet[] public multiBets;
}

contract Gambling is StorageHelper {
    event NewGambling(address owner, uint matchId);
    event FinishMatch(uint matchId, uint winTeam);
    event ChargeGambling(address owner, uint matchId);

    function createP2PBet() external {

        P2PBet({
            creator: msg.sender,
            betCreator: _currency,
            payPlayer: 0,
            player: msg.sender,
            betPlayer: _model,
            payCreator: _oracle
        });

        Status status;

        bytes32 gambling;
        IBetOracle oracle;

        _createBet(gambling, oracle);



        Match storage matchAux = matches[_matchId];
        require(matchAux.timeNoMoreBets >= now, "the bets should are opened");
        require(addressToBalance[msg.sender] >= _value , "insufficient founds");

        addressToBalance[msg.sender] -= _value;

        if(matchAux.addressToTeam[msg.sender] == 0){
            matchAux.addressToTeam[msg.sender] = _winTeamId;
        } else {
            _winTeamId = matchAux.addressToTeam[msg.sender];
        }

        if(_winTeamId == matchAux.team1){
            matchAux.balance1 += _value;
        }else{
            if(_winTeamId == matchAux.team2){
                matchAux.balance2 += _value;
            }else{
                matchAux.balanceD += _value;
            }
        }

        matchAux.addressToBalance[msg.sender] += _value;
    }

    function chargeGambling(uint _matchId, address _owner) public {
        Match storage matchAux = matches[_matchId];
        uint winTeam = matchAux.winTeam;
        require(winTeam != 0, "team win should not be None");
        require(matchAux.addressToBalance[_owner] > 0, "the owner dont have gambling or its charged");
        require(matchAux.addressToTeam[_owner] == winTeam, "the sender dont win");

        uint userBal = matchAux.addressToBalance[_owner];
        matchAux.addressToBalance[_owner] = 0;

        if(winTeam == matchAux.team1){
            addressToBalance[_owner] += getTotalwin(userBal, matchAux.balance1, matchAux.balanceD + matchAux.balance2);
        }else{
            if(winTeam == matchAux.team2){
                addressToBalance[_owner] += getTotalwin(userBal, matchAux.balance2, matchAux.balance1 + matchAux.balanceD);
            }else{// draw
                addressToBalance[_owner] += getTotalwin(userBal, matchAux.balanceD, matchAux.balance1 + matchAux.balance2);
            }
        }
        emit ChargeGambling(_owner, _matchId);
    }

    function getTotalwin(uint _userBal, uint _totWinBal, uint _totLoseBal) internal pure returns(uint) {
        return ((_userBal * _totLoseBal) / _totWinBal) + _userBal;
    }
}

pragma solidity ^0.4.25;

import "./utils/Ownable.sol";
import "./utils/Safemath.sol";

import "./interfaces/IGamblingModel.sol";
import "./interfaces/IGameOracle.sol";
import "./interfaces/Token.sol";


contract BalanceManager {
    event Deposit(address from, address to, address currency, uint256 amount);
    event Withdraw(address from, address to, address currency, uint256 amount);

    // [wallet/contract, currency] to balance
    mapping (address => mapping (address => uint256)) public toBalance;

    function () external payable {
        toBalance[msg.sender][0x0] += msg.value;
        emit Deposit(msg.sender, msg.sender, 0x0, msg.value);
    }

    function deposit(address _to, address _currency, uint256 _amount) external payable returns(bool) {
        require(_to != 0x0, "_to should not be 0x0");

        if(_currency == 0x0)
            require(_amount == msg.value);
        else
            require(Token(_currency).transferFrom(_to, address(this), _amount) && msg.value == 0, "Error pulling tokens, in deposit");

        toBalance[_to][_currency] += _amount;

        emit Deposit(msg.sender, _to, _currency, _amount);

        return true;
    }

    function withdraw(address _to, address _currency, uint256 _amount) external returns(bool) {
        require(_to != 0x0, "_to should not be 0x0");
        require(toBalance[_to][_currency] >= _amount, "Insufficient funds to discount");

        toBalance[_to][_currency] -= _amount;

        if(_currency == 0x0)
            _to.transfer(_amount);
        else
            require(Token(_currency).transferFrom(address(this), _to, _amount), "Error pulling tokens, in withdraw");

        emit Withdraw(msg.sender, _to, _currency, _amount);

        return true;
    }

    function withdrawAll(address _to, address _currency) external returns(bool) {
        require(_to != 0x0, "_to should not be 0x0");
        uint256 addrBal = toBalance[msg.sender][_currency];
        toBalance[msg.sender][_currency] = 0;

        if(_currency == 0x0)
            _to.transfer(addrBal);
        else
            require(Token(_currency).transferFrom(address(this), _to, addrBal), "Error pulling tokens, in withdraw");

        emit Withdraw(msg.sender, _to, _currency, addrBal);

        return true;
    }
}

contract IdHelper {
    mapping(address => uint256) public nonces;

    function buildId(address _creator, uint256 _nonce, bool withNonce ) external pure returns (bytes32) {
        return keccak256(abi.encodePacked(_creator, _nonce, withNonce));
    }
}

contract GamblingManager is BalanceManager, IdHelper {
    struct Bet {
        IGambling gambling;
        address currency;
        uint256 balance;
    }

    mapping(bytes32 => Bet) public bets;

    function create(
        address _currency,
        IGambling _gambling,
        bytes _data
    ) external returns(bytes32 betId){
        uint256 nonce = nonces[msg.sender]++;
        betId = keccak256(abi.encodePacked(msg.sender, nonce, false));

        _create(
            betId,
            _currency,
            _gambling,
            _data
        );
    }

    function createWithNonce(
        uint256 nonce,
        address _currency,
        IGambling _gambling,
        bytes _data
        ) external returns(bytes32 betId){
        betId = keccak256(abi.encodePacked(msg.sender, nonce, true));

        _create(
            betId,
            _currency,
            _gambling,
            _data
        );
    }

    function _create(
        bytes32 _betId,
        address _currency,
        IGambling _gambling,
        bytes _data
    ) internal {
        require(bets[_betId].gambling != address(0x0), "The bet is already created");

        uint256 needAmount = _gambling.createBet(_betId, _data);

        // Substract balance from BalanceManager
        require(toBalance[msg.sender][_currency] >= needAmount, "Insufficient funds to discount from wallet/contract");
        toBalance[msg.sender][_currency] -= needAmount;

        bets[_betId] = Bet({
            gambling: _gambling,
            currency: _currency,
            balance:  needAmount
        });
    }

    function play(
        bytes32 _betId,
        bytes _data
    ) external returns(bool){
        Bet storage bet = bets[_betId];

        uint256 needAmount = bet.gambling.playBet(_betId, msg.sender, _data);

        // Substract balance from BalanceManager
        require(toBalance[msg.sender][bet.currency] >= needAmount, "Insufficient funds to discount from wallet/contract");
        toBalance[msg.sender][bet.currency] -= needAmount;
        // Add balance to Bet
        bet.balance += needAmount;

        return true;
    }
/*
    function quickPlay(
        IGambling _gambling,
        address _currency,
        bool _withdraw,
        bytes _data
    ) external payable returns(bool){
        deposit(address _to, address _currency, uint256 _amount)
        require(bets[_betId].gambling != address(0x0), "The bet is already created");

        uint256 needAmount = bet.gambling.quickPlayBet(_betId, _data);

        // Substract balance from BalanceManager
        require(toBalance[msg.sender][_currency] >= needAmount, "Insufficient funds to discount from wallet/contract");
        toBalance[msg.sender][_currency] -= needAmount;

        bets[_betId] = Bet({
            gambling: _gambling,
            currency: _currency,
            balance:  needAmount
        });

        Bet storage bet = bets[_betId];


        // Substract balance from BalanceManager
        require(toBalance[msg.sender][bet.currency] >= needAmount, "Insufficient funds to discount from wallet/contract");
        toBalance[msg.sender][bet.currency] -= needAmount;
        // Add balance to Bet
        bet.balance += needAmount;

        return true;
    }
*/
    function collect(
        bytes32 _betId
    ) external returns(bool){
        Bet storage bet = bets[_betId];

        uint256 needAmount = bet.gambling.collectBet(_betId, msg.sender);

        // Substract balance from Bet
        require(bet.balance >= needAmount, "Insufficient funds to discount from bet balance");
        bet.balance -= needAmount;
        // Add balance to BalanceManager
        toBalance[msg.sender][bet.currency] += needAmount;

        return true;
    }

    function cancel(
        bytes32 _betId
    ) external returns(bool){
        Bet storage bet = bets[_betId];

        bet.gambling.cancelBet(_betId, msg.sender);

        uint256 betBalance = bet.balance;
        bet.balance = 0;
        // Add balance to BalanceManager
        toBalance[msg.sender][bet.currency] += betBalance;

        return true;
    }
}
